<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en"><generator uri="https://jekyllrb.com/" version="3.9.3">Jekyll</generator><link href="http://localhost:4000/feed.xml" rel="self" type="application/atom+xml" /><link href="http://localhost:4000/" rel="alternate" type="text/html" hreflang="en" /><updated>2024-03-25T01:20:41+09:00</updated><id>http://localhost:4000/feed.xml</id><title type="html">Youngman</title><subtitle>Hydejack is a boutique Jekyll theme for hackers, nerds, and academics, with a focus on personal sites that are meant to impress.
</subtitle><author><name>Youngeon</name><email>kye8456@naver.com</email></author><entry><title type="html">Programming Content</title><link href="http://localhost:4000/programming/programming-content/" rel="alternate" type="text/html" title="Programming Content" /><published>2022-12-29T00:00:00+09:00</published><updated>2024-03-14T20:51:29+09:00</updated><id>http://localhost:4000/programming/programming-content</id><content type="html" xml:base="http://localhost:4000/programming/programming-content/">&lt;p&gt;안녕하세요. Programming,&lt;/p&gt;

&lt;h1 id=&quot;programming&quot;&gt;PROGRAMMING&lt;/h1&gt;

&lt;p&gt;&lt;strong&gt;Programming&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;2023년&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;start&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;c--python&quot;&gt;C++ / Python&lt;/h2&gt;

&lt;h3 id=&quot;code&quot;&gt;Code&lt;/h3&gt;

&lt;div class=&quot;language-js highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c1&quot;&gt;// Example can be run directly in your JavaScript console&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Create a function that takes two arguments and returns the sum of those&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// arguments&lt;/span&gt;
&lt;span class=&quot;kd&quot;&gt;var&lt;/span&gt; &lt;span class=&quot;nx&quot;&gt;adder&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;Function&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;b&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;return a + b&lt;/span&gt;&lt;span class=&quot;dl&quot;&gt;&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;// Call the function&lt;/span&gt;
&lt;span class=&quot;nx&quot;&gt;adder&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;6&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;// &amp;gt; 8&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;</content><author><name>Youngeon</name><email>kye8456@naver.com</email></author><category term="programming" /><summary type="html">안녕하세요. Programming,</summary></entry><entry><title type="html">nvidia_graphic_card 인식 해결</title><link href="http://localhost:4000/devops/nvidia_graphic_card_content/" rel="alternate" type="text/html" title="nvidia_graphic_card 인식 해결" /><published>2022-11-28T00:00:00+09:00</published><updated>2024-03-25T00:49:39+09:00</updated><id>http://localhost:4000/devops/nvidia_graphic_card_content</id><content type="html" xml:base="http://localhost:4000/devops/nvidia_graphic_card_content/">&lt;h2 id=&quot;ubuntu-2204-설치-후-nvidia_drivegraphic-card-설치&quot;&gt;ubuntu 22.04 설치 후 nvidia_drive(graphic card) 설치&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;먼저 ubuntu22.04를 설치하고 실행하였는데 그래픽 카드 인식 오류가 발생한다면 PC 뒤에서 Display Port (or HDMI) 를 그래픽카드가 아닌 마더보드에 연결할 수 있도록 하고 재부팅한다. 그리고 terminal 창을 열어서 그래픽 카드에 적합한 드라이버를 검색한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo ubuntu-drivers devices&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/DevOps/images/nvidia/image.png&quot; alt=&quot;Untitled1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;드라이버 중 추천해주는 모델을 설치를 진행한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo apt install nvidia-driver-{number}&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;nvidia 드라이버 모델 설치가 완료된 것을 확인한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;nvidia-smi&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/DevOps/images/nvidia/image1.png&quot; alt=&quot;Untitled2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;정상적으로 진행이 되었다면 nvidia 드라이버가 설치가 되었으니 그래픽카드로 부터 HDMI를 연결해 디스플레이를 확인할 수 있다.&lt;/p&gt;</content><author><name>Youngeon</name><email>kye8456@naver.com</email></author><category term="DevOps" /><summary type="html">ubuntu 22.04 설치 후 nvidia_drive(graphic card) 설치</summary></entry><entry><title type="html">Manipulator</title><link href="http://localhost:4000/robotics/robotics-content/" rel="alternate" type="text/html" title="Manipulator" /><published>2022-06-12T00:00:00+09:00</published><updated>2024-03-20T00:08:52+09:00</updated><id>http://localhost:4000/robotics/robotics-content</id><content type="html" xml:base="http://localhost:4000/robotics/robotics-content/">&lt;p&gt;6자유도 협동로봇의 Matlab 시뮬레이션&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/robotics/images/robotics_2/Untitled.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ⅰ-d-h-파라미터&quot;&gt;Ⅰ. D-H 파라미터&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;D-H 파라미터는 기계 공학의 로봇팔과 같이 연결된 링크 간의 관계를 수학적으로 표현할 수 있는 기구학적인 모델링 방법을 활용한 매개변수이다. 총 4개의 매개변수가 있으며 각각의 매개변수는 링크의 좌표계 설정하여 두 개의 링크 간의 좌표계를 나타낸다. D-H 파라미터를 구하기 전에 좌표계를 설정한다. 조인트에서의 좌표의 원점을 Oi점으로 정한 후 각 조인트에서 움직이는 축을 중심으로 Z축을 설정한다. 로봇의 회전 축을 중심으로 Z축을 선정하는데 이 때 엄지손가락이 가리키는 방향이 Z축이며 오른손 법칙을 이용한다. Z축을 오른손법칙으로 선정하였을 때 검지 손가락이 가리키는 방향이 X축이며 이 X축은 Zi-1 축과 Zi 축에 수직인 평면으로 Zi-1에서 밖으로 나가는 방향으로 Oi를 지나 Zi 축에 수직하다. 이후 Y축은 Z축과 X축에 의해 오른손법칙으로 정해진다. D-H파라미터를 설정할 때 간편히 하기 위해 회전축이 없는 End_effector는 가능하면 이전 축을 기준으로 같은 방향으로 설정하는 것이 좋다. 좌표계가 설정되고 난 후 D-H파라미터를 구하기 위해서는 각 좌표축간의 관계를 파악해야한다. D-H파라미터는 d, θ, a, α 가 있으며 각각의 의미는 다음과 같다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;d-h-파라미터&quot;&gt;D-H 파라미터&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;d : Zi 축을 기준으로 Xi 축 Xi+1 축 사이의 최단 거리&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;θ : Zi 축을 기준으로 Xi 축 Xi+1 축 사이의 각도&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;a : Xi 축을 기준으로 Zi 축과 Zi+1 축 사이의 최단 거리&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;α : Xi 축을 기준으로 Zi 축과 Zi+1 축 사이의 각도&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/robotics/images/robotics_2/Untitled_1.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;6 axis D-H parameters&lt;/p&gt;

\[A_{i-1}^{i} = \left[\begin{array}{}
    cos(\theta_i) &amp;amp; cos(\alpha_i)sin(\theta_1) &amp;amp; sin(\alpha_i)sin(\theta_i) &amp;amp; a_icos(\theta) \\
    sin(\theta_i) &amp;amp; cos(\alpha_i)cos(\theta_i) &amp;amp; -sin(\alpha_i)cos(\theta_i) &amp;amp; a_isin(\theta_i) \\
    0 &amp;amp; sin(\alpha_i) &amp;amp; cos(\alpha_i) &amp;amp; d_i \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1
    \end{array}\right]\]

&lt;p class=&quot;figcaption&quot;&gt;translation matrix&lt;/p&gt;

&lt;h2 id=&quot;ⅱ베이스좌표계x_0y_0z_0로부터end-effector까지의천이행렬&quot;&gt;Ⅱ. 베이스좌표계$(x_{0},y_{0},z_{0})$로부터 End-effector까지의 천이행렬&lt;/h2&gt;

&lt;p&gt;좌표계를 설정하고 D-H 파라미터를 구한 후 Translation 행렬에 대입하여 T행렬을 계산한다. T행렬은 Rotation matrix와 Position matrix로 구성되어 있으며 Rotation matrix는 Roll, Pitch, Yaw의 방향으로 회전한 행렬을 모두 연산하여 3 x 3 행렬로 구성되고 Position matrix는 X, Y, Z로 3 x 1 행렬로 구성되어 있으며 차원을 맞춰주기 위하여 전체 행렬은 4 x 4 행렬로 구성한다. T행렬은 각 D-H파라미터를 대입하여 0번 조인트에서 1번 조인트까지의 관계, 1번 조인트에서 2번 조인트까지의 관계를 계속해서 나타내고 최종적으로 나타내고자하는 n-1번 조인트에서 n번 조인트까지의 관계까지 모두 계산한 다음 이런 T행렬을 T_0_1부터 T_n-1_n 까지의 곱으로 초기 좌표계에서 구하고자하는 End-effector까지의 관계(회전과 위치)를 구할 수 있다.&lt;/p&gt;

&lt;p&gt;전체 변환 행렬 (은 n좌표에서 오리엔테이션 행렬, 은 n좌표에서 위치 벡터)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/robotics/images/robotics_2/Untitled_2.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ⅲ-순기구학을-이용하여-각-링크의-관절각을-표현할-수-있는-matlab-시뮬레이션-프로그램을-구현&quot;&gt;Ⅲ. 순기구학을 이용하여 각 링크의 관절각을 표현할 수 있는 Matlab 시뮬레이션 프로그램을 구현&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Matlab 시뮬레이션은 2개의 함수.m 파일과 3개의 실행.m 파일로 구성했다. 먼저 함수 파일의 theta.m 파일은 T행렬을 계산하기 위해 D-H파라미터를 대입할 수 있는 행렬을 함수로 나타내었고 ficture.m 파일은 D-H파라미터를 직접 입력해주고 theta.m 파일의 함수를 활용하여 plot을 띄우면서 각 링크, 조인트의 위치를 나타내고 End-effector의 위치 또한 추가적으로 좌표를 표시했다. DOF_6.m 파일은 ficture.m 파일의 기본적인 위치를 표시하기 위한 파일로 D-H 파라미터 중 변수인 θ1 부터 θ6 까지의 default 값을 0으로 지정하여 초기의 협동로봇의 위치를 나타내었다. DOF_6_exe.m 파일은 사용자가 직접 변수를 입력할 수 있도록 하였다. 먼저 사용자의 입력이 Y 또는 y이면 각 θn 에 동일한 값을 입력받고 반복횟수를 입력받아 전체적인 협동로봇의 형상이 초기상태부터 차례대로 진행되며 겹쳐보일 수 있도록 하였다. 사용자가 입력을 N 또는 n으로 입력하면 하나의 협동로봇의 형상만 표시하는 것으로 각각의 θn 값을 입력받아 θn 값에 의해 변하는 plot을 살펴볼 수 있도록 하였다. Fun_Link.m 파일은 line 5에 loop 값에 따라 달라지는 협동로봇의 형상을 표현한다. 링크와 조인트의 통일된 색상으로 DOF_6_exe.m 파일보다 조금 더 전체적인 로봇의 큰 틀의 형상을 살펴볼 수 있다. matlab에서 plot의 비율을 조정하기 위해 축의 범주를 한정해두면 협동로봇의 형태가 축의 범주를 넘어서면 표현되지 않는다. 각 매트랩파일에서 axis에 대한 설명부분을 주석처리하면 비율은 맞지 않으나 End_effector이 표현되지 않는 경우는 없다. (매트랩 결과로 출력된 좌표 중 –7.164e-15의 값은 실제 값은 0이다.)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/robotics/images/robotics_2/Untitled_3.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/robotics/images/robotics_2/Untitled_4.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;Matlab Simulation result&lt;/p&gt;

&lt;p&gt;Matlab으로 구현한 시뮬레이션이 실제 계산결과와 동일한 결과를 출력하는지 검산할 필요가 있다. 따라서 시뮬레이션에서 대입한 θn = 60 로 설정하여 D-H파라미터 값으로 전이행렬을 옳게 출력하고 위치벡터(X,Y,Z)의 결과로 End-effector의 위치와 동일한 결과인지 판단한다. 예를 들어 θ2 = 60, θ5 = 60로 설정하여 검산과정을 진행한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/robotics/images/robotics_2/Untitled_5.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;Link의 행렬들을 모두 연산하면&lt;/p&gt;

\[A = 10^3  \begin{bmatrix}0&amp;amp;-0.001&amp;amp;0&amp;amp;0.117 \\ 0.001 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1.1704 \\ 0 &amp;amp; 0  &amp;amp; 0.001 &amp;amp; 1.1272 \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 0.001 \end{bmatrix}\]

&lt;p&gt;위치벡터의 값이 117,1170,1127이므로 End_effector의 좌표 (X,Y,Z) = (117, 1170, 1127)이다. 시뮬레이션 결과와 동일한 것을 확인할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/robotics/images/robotics_2/Untitled_6.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ⅴ-경로계획-방법을-이용하여-로봇팔의-end-effector의-경로를-cubic-spline-이용해서-작성&quot;&gt;Ⅴ. 경로계획 방법을 이용하여 로봇팔의 End-effector의 경로를 Cubic Spline 이용해서 작성&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;path planning을 진행하기 위해서는 현재 위치와 도착 위치를 설정한 후 두 점을 잇는 경로를 계획한다. 두 점을 잇는 경로는 다양하며 로봇이 일반적으로 움직이는 경로를 설정할 때 도달시간이 빠르며 안정적으로 이동경로를 설정하여 도착 위치에 도달하는 것이다. 출발 위치와 도착 위치를 바로 잇는 직선이 가장 빠른 경로는 맞지만 실제 로봇의 이동경로를 두점을 잇는 경로가 항상 안정적으로 동작하는 것은 아니다. 실제 로봇의 이동경로를 PD제어를 통해 추종하는 프로그램을 진행할 때 이동 포인트를 정확히 통과하고 다음 이동 포인트로 방향각을 설정하기 위해 선회하는 것으로 나타난다. 마찬가지로 로봇팔에서도 포인트 이동에서 직선으로 바로 도달하는 것이 안정적이지는 않다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/robotics/images/robotics_2/Untitled_7.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;추가적으로 로봇이 이동할 때 정지, 등속, 정지의 과정으로 로봇이 작동하지 못한다. 따라서 실제로 로봇의 정지, 가속, 등속, 감속, 정지의 과정을 거치며 이동경로를 설정하고 부드러운 모션으로 진행할 수 있도록 하기 위해 Cubic Spline을 이용한다. Cubic Spline의 조건으로 로봇의 출발 위치에서 각도는 0이고 각속도 또한 0이다. 도착지점에서의 위치는 설정한 값이 존재하지만 마찬가지로 각속도는 0으로 설정된다. 아래의 왼쪽 그림과 마찬가지로 함수가 어느 한 점에서 불연속으로 진행할 수 없다. 이러한 조건을 만족 시키면서 가속, 감속 과정을 진행하기 위해서는 실제로 아래의 오른쪽 그림과 같이 X 축(시간축)에 대한 Y 축(각도)의 변화로 나타낼 수 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/robotics/images/robotics_2/Untitled_8.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;실제 시뮬레이션 결과 6자유도 협동로봇의 전체 형상 및 움직이는 각도는 θ3 값에 입력 값으로 진행하였다. Cubic Spline의 위치, 속도, 가속도를 그래프로 시간에 대한 변화를 나타내고 마지막 그래프에서는 End-effector의 위치를 나타냈다. Cubic Spline 함수는 아래와 같이 설정하였다.&lt;/li&gt;
&lt;/ul&gt;

\[\theta(t) = A(1-cos(\frac{n\pi}{T})t)\]

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/robotics/images/robotics_2/Untitled_9.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ⅵ-설정된-경로를-추종하는-관절각을-계산하는-역기구학-시뮬레이션-코드를-작성&quot;&gt;Ⅵ. 설정된 경로를 추종하는 관절각을 계산하는 역기구학 시뮬레이션 코드를 작성&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;역기구학은 로봇의 위치가 정의되어 있을 때 현재 로봇의 End-effector에서 θ의 값을 구하기 위해 End-effector의 위치에서 atan2의 함수를 이용해서 기울어진 각도를 반대로 계산해 나가는 과정이다. 이때 atan2를 활용하는 이유는 atan은 θ의 값이 0 ~ 2π으로 지정되어 있어 π의 값에서 tanθ의 값이 발산하는 결과가 발생하기 때문에 atan2는 θ의 값이 -π ~ π 으로 설정되어 tanθ의 값이 불연속인 구간이 없다.&lt;/li&gt;
&lt;/ul&gt;

\[A^i_i-1 = \begin{bmatrix}cos( \theta_i) &amp;amp; -cos(\alpha_i)sin(\theta_i) &amp;amp; sin(\alpha_i)sin(\theta_{i}) &amp;amp; a _{i}cos(\theta) \\ sin(\theta_{i}) &amp;amp; cos(\alpha_{i})cos(\theta_{i}) &amp;amp; -sin(\alpha_{i})cos(\theta_{i}) &amp;amp; a_{i}sin(\theta_{i}) \\ 0 &amp;amp; sin(\alpha_{i}) &amp;amp; cos(\alpha_{i} ) &amp;amp; d_{i} \\ 0 &amp;amp; 0 &amp;amp; 0 &amp;amp; 1 \end{bmatrix}\]

&lt;p&gt;변환행렬에서 a의 값이 0이기 때문에 위치 벡터에서의  에서 tanθ의 값이  이기 때문에 값이 없어서 역기구학을 계산할 수 없다.&lt;/p&gt;</content><author><name>Youngeon</name><email>kye8456@naver.com</email></author><category term="robotics" /><summary type="html">6자유도 협동로봇의 Matlab 시뮬레이션</summary></entry><entry><title type="html">Mathmatics</title><link href="http://localhost:4000/mathematics/mathematics-content/" rel="alternate" type="text/html" title="Mathmatics" /><published>2022-04-12T00:00:00+09:00</published><updated>2024-03-25T00:28:28+09:00</updated><id>http://localhost:4000/mathematics/mathematics-content</id><content type="html" xml:base="http://localhost:4000/mathematics/mathematics-content/"></content><author><name>Youngeon</name><email>kye8456@naver.com</email></author><category term="mathematics" /><summary type="html"></summary></entry><entry><title type="html">Git</title><link href="http://localhost:4000/devops/git-content/" rel="alternate" type="text/html" title="Git" /><published>2022-01-10T00:00:00+09:00</published><updated>2024-03-25T01:15:22+09:00</updated><id>http://localhost:4000/devops/git-content</id><content type="html" xml:base="http://localhost:4000/devops/git-content/">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/DevOps/images/git/image.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Git은 분산 버전 관리 시스템(Distributed Version Control System, DVCS) 중 하나로, 소스 코드와 같은 파일의 변경 사항을  추적하고 관리하는 도구&lt;/li&gt;
  &lt;li&gt;파일의 변경사항을 추적하여 이전 상태로 롤백하거나 변경 내용을 비교할 수 있다. 또한 여러 개발자 간의 협업을 용이하게 하며 변경사항의 충돌을 관리&lt;/li&gt;
  &lt;li&gt;브랜치를 통해서 여러 작업을 병렬로 처리할 수 있다. 각 브랜치는 개별적으로 관리되며 변강사항을 통합할 수 있다.&lt;/li&gt;
  &lt;li&gt;원격 저장소를 통해 다른 개발자와 협업하고 코드를 공유할 수 있다. 원격저장소로는 Github, GitLab, Bitbucket 등이 있다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;ubuntu-에-git-설치&quot;&gt;Ubuntu 에 git 설치&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;sudo apt install git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Ubuntu에 git을 설치하는 CLI는 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git --version&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;설치가 완료되었다면 설치된 Git 버전을 다음 CLI를 통해서 확인 할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;github에서-clone하기&quot;&gt;github에서 clone하기&lt;/h2&gt;

&lt;p align=&quot;center&quot;&gt;
![Untitled](https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/DevOps/images/git/image2.png)
&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git clone 클론하고자 하는 래퍼지토리&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;ex, &lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git clone [https://github.com/eeoon/eeoon.git](https://github.com/eeoon/eeoon.git)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;옵션을 통해서 원하는 branch를 clone할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git clone https://github.com/eeoon/eeoon.git -b humble&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;github에-push하기&quot;&gt;github에 push하기&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://github.com/&quot;&gt;GitHub: Let’s build from here&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;내 github에 push하기 위해서는 사전작업으로 Github에 가입하여 내 repository를 생성하고 해당 repository로 내가 작업중이던 코드, 프로젝트 등을 push 할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;Github에 가입하였다면&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git config --global user.name &quot;Your Name&quot;&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git config --global user.email &quot;your.email@example.com&quot;&lt;/code&gt;&lt;/p&gt;

    &lt;p&gt;명령을 진행한다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;사용자의 이름, 이메일 주소를 설정한다. option으로 global로 설정되어 있기 때문에 전역적으로 설정되었고 local설정으로 변경할 때에는 해당 옵션 없이 진행하면 된다. 현재 전역으로 설정되었기에 추가적으로 반복해서 진행할 필요는 없다.&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;github-repositry-생성&quot;&gt;Github Repositry 생성&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/DevOps/images/git/image3.png&quot; alt=&quot;Screenshot1&quot; /&gt;&lt;/p&gt;

&lt;p&gt;회원가입이 완료되었다면 your Repositories에 클릭하여 우측 상단의 New를 클릭한다.&lt;/p&gt;

&lt;p&gt;다음과 같은 화면이 나타나면 Repository name을 작성하고 옵션으로 Description, Properties 등을 설정한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/DevOps/images/git/image4.png&quot; alt=&quot;Screenshot2&quot; /&gt;&lt;/p&gt;

&lt;p&gt;만들어진 repository를 확인한 후 우측 상단의 Code를 누른 후 url를 Copy 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/DevOps/images/git/image5.png&quot; alt=&quot;Screenshot3&quot; /&gt;&lt;/p&gt;

&lt;p&gt;내 Desktop에서 Github에 올릴 repository에 접속하여 다음의 명령을 수행한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git init&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;로컬에서 Github에 올릴 프로젝트 디렉토리에서 Git을 초기화&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git add .&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;프로젝트 파일을 Git으로 관리하기 위해 파일 추가 및 커밋&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git commit -m “커밋 메시지”&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;커밋할 메시지를 추가하여 커밋을 진행한다.&lt;/p&gt;

&lt;p&gt;이때 커밋할 메시지는 git push 되었을때 변경사항에 대한 간략한 설명을 뜻한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git remote add origin https://github.com/사용자이름/저장소이름.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Github에 생성한 원격저장소를 로컬 Git에 추가한다.&lt;/p&gt;

&lt;p&gt;여기서 위 사진에서 복사한 url을 입력한다.&lt;/p&gt;

&lt;p&gt;ex,&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git remote add origin https://github.com/eeoon/example.git&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git checkout -b main&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;branch를 변경한다. 새로운 branch를 생성하고 해당 branch로 전환할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git branch -m master main&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git fetch origin&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git branch -u origin/main main&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;만약 branch가 다른곳(master)이라면 이름을 변경해줘야한다.&lt;/p&gt;

&lt;p&gt;혹시나 위의 방법이 안된다면 아래의 방법을 진행&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git checkout -b main&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git checkout main&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git merge origin/main&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git push origin main&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;로컬의 변경 사항을 원격 저장소(Github)에 푸쉬한다.&lt;/p&gt;

&lt;p&gt;만약 마지막 단계를 진행했을때도 실패한 경우에는&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;git push origin +main&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;입력하여 강제로 git push 할 수 있다.&lt;/p&gt;

&lt;p&gt;git push가 정상적으로 진행되었다면 다음과 같은 결과를 볼 수 있다. (commit message를 picture로 설정)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/DevOps/images/git/image6.png&quot; alt=&quot;Screenshot4&quot; /&gt;&lt;/p&gt;</content><author><name>Youngeon</name><email>kye8456@naver.com</email></author><category term="DevOps" /><summary type="html"></summary></entry><entry><title type="html">Docker</title><link href="http://localhost:4000/devops/docker-content/" rel="alternate" type="text/html" title="Docker" /><published>2021-12-12T00:00:00+09:00</published><updated>2024-03-25T00:42:06+09:00</updated><id>http://localhost:4000/devops/docker-content</id><content type="html" xml:base="http://localhost:4000/devops/docker-content/">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/DevOps/images/docker/image.png&quot; alt=&quot;docker-logo-blue.png&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;도커(Docker)는 리눅스 응용 프로그램을 프로세스 격리 기술들을 사용해 컨테이너로 실행하고 관리하는 컨테이너 기반 가상화 플랫폼 소프트웨어를 환경에서 격리된 단위로 패키징하고 배포할 수 있다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;도커 컨테이너의 장점으로 소프트웨어 실행에 필요한 모든 것을 포함하는 완전한 파일 시스템 안에 wrapping 되어 있기 때문에 실행중인 환경에 관계 없이 언제나 동일하게 실행되는 결과가 나타난다.&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;도커 이미지
    &lt;ul&gt;
      &lt;li&gt;도커 이미지는 애플리케이션을 실행하는데 필요한 모든 것을 포함하고 있는 파일 시스템&lt;/li&gt;
      &lt;li&gt;Dockerfile을 사용하여 이미지를 정의하고 도커 CLI를 사용하여 빌드할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;도커 컨테이너
    &lt;ul&gt;
      &lt;li&gt;도커 이미지의 인스턴스로, 파일 시스템과 애플리케이션 실행환경을 가지고 있다.&lt;/li&gt;
      &lt;li&gt;컨테이너는 독립적이지만 호스트 시스템의 리소스를 공유할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;도커 레지스트리
    &lt;ul&gt;
      &lt;li&gt;도커 이미지를 저장하고 공유하는데 사용되는 저장소&lt;/li&gt;
      &lt;li&gt;Docker Hub는 가장 널리 사용되고 있는 플랫폼&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;도커 컴포즈
    &lt;ul&gt;
      &lt;li&gt;도커 애플리케이션을 정의하고 실행하기 위한 도구&lt;/li&gt;
      &lt;li&gt;YAML 파일을 사용하여 여러 컨테이너를 정의하고 단일 명령어로 애플리케이션을 시작할 수 있다.&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;도커 스윔
    &lt;ul&gt;
      &lt;li&gt;도커 클러스터링과 오케스트레이션 도구, 여러 호스트에서 도커 컨테이너를 관리하고 배포할 수 있다.&lt;/li&gt;
      &lt;li&gt;swarm을 사용하여 서비스를 확장하고 높은 가용성을 확보&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/DevOps/images/docker/image1.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;docker-command&quot;&gt;docker command&lt;/h2&gt;

&lt;p&gt;자주 사용하는 docker command 에 대한 설명&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker pull image_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Docker Hub 또는 다른 Docker 레지스트리에서 이미지를 가져온다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker commit container image_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;실행중인 컨테이너를 이미지로 커밋한다. (컨테이너를 이미지화)&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker run --options&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;docker image에서 container를 생성하고 실행하는데 사용된다. 여러 옵션들이 있다.&lt;/p&gt;

&lt;p&gt;-d : container를 백그라운드에서 실행하도록 지정&lt;/p&gt;

&lt;p&gt;-v : host와 container의 디렉토리를 공유&lt;/p&gt;

&lt;p&gt;-e : container 내부의 환경변수를 설정&lt;/p&gt;

&lt;p&gt;–name : 실행할 container의 이름을 지정&lt;/p&gt;

&lt;p&gt;-it : container를 인터랙티브하게 실행&lt;/p&gt;

&lt;p&gt;etc..&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker ps&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;docker 환경에서 실행중인 container list를 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker ps -a&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;docker 환경의 전체 container list를 나타낸다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker image list&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Docker image list를 볼 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker rm container_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Docker container 를 삭제할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker rm image_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Docker image를 삭제할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker exec -it container_name /bin/bash&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Docker에서 실행중인 container 내부에 인터랙티브한 bash 셸이 실행되어 접속할 수 있다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker attach container_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;실행중인 container에 연결하여 터미널을 제어한다.&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker start container_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;docker stop container_name&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;container를 시작하거나 중지할 수 있다.&lt;/p&gt;

&lt;h2 id=&quot;local에서-display-공유&quot;&gt;local에서 DISPLAY 공유&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;language-plaintext highlighter-rouge&quot;&gt;xhost +local:&lt;/code&gt;&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;도커의 장점으로 개발 환경, 테스트 환경, 프로덕션 환경 등을 일관되게 유지할 수 있다.&lt;/li&gt;
  &lt;li&gt;가상화된 컨테이너는 가볍고 빠르게 시작되므로 자원을 효율적으로 사용할 수 있다.&lt;/li&gt;
  &lt;li&gt;컨테이너는 어디서든 동일하게 실행될 수 있어 이식성이 뛰어나다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Youngeon</name><email>kye8456@naver.com</email></author><category term="DevOps" /><summary type="html"></summary></entry><entry><title type="html">Computer Vision</title><link href="http://localhost:4000/project/project-content/" rel="alternate" type="text/html" title="Computer Vision" /><published>2021-12-12T00:00:00+09:00</published><updated>2024-03-20T00:08:52+09:00</updated><id>http://localhost:4000/project/project-content</id><content type="html" xml:base="http://localhost:4000/project/project-content/">&lt;p&gt;&lt;strong&gt;Vanishing Point &amp;amp; Perspective Transform&lt;/strong&gt;&lt;/p&gt;

&lt;!-- *2023년* 

- start
--&gt;
&lt;h2 id=&quot;vanishing-point--perspective-transform&quot;&gt;Vanishing Point &amp;amp; Perspective Transform&lt;/h2&gt;

&lt;h3 id=&quot;영상처리를-통한-자율주행&quot;&gt;영상처리를 통한 자율주행&lt;/h3&gt;

&lt;p&gt;&lt;strong&gt;project propose : Vanishing point를 활용하여 주행 방향을 결정할 때 발생되는 오차를 Lane detection을 통해 보안&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;영상 처리 과정에서 라인을 검출하여 만나는 지점의 소실점(Vanishing Point)를 활용하여 주행방향(조향)을 결정한다.&lt;/li&gt;
  &lt;li&gt;소실점이 생성되는 과정에서 발생되는 오차는 박스를 설정하여 소실점이 박스를 벗어났는지 판단하는 과정을 진행한다.&lt;/li&gt;
  &lt;li&gt;카메라가 인식하는 2차원을 Perspective Transform의 과정을 거쳐 라인을 검출하였다.&lt;/li&gt;
  &lt;li&gt;카메라를 통해 검출된 소실점과 라인 검출을 통해 새로운 해석을 도입한다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;vanishing-point&quot;&gt;Vanishing Point&lt;/h2&gt;

&lt;p&gt;3D 공간에서 평행한 직선은 2D 영상에서 FOV(Field of View)로 인하여 평행하게 보이지 않는다. 간단한 예시로 도로위의 차선은 bird of view로 바라보면 평행하나 운전자의 입장(카메라)에서 바라보면 평행하지 않게 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_1.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;basic of concept&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_2.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;figcaption&quot;&gt;실제 이미지에 적용한 Vanishing point로 lane을 검출하여 lane의 접점을 red dot으로 표시하였다.&lt;/p&gt;

&lt;h2 id=&quot;perspective-transform&quot;&gt;Perspective Transform&lt;/h2&gt;

&lt;p&gt;관심영역과 평행이 아닐 때 수집한 영상을 대상체와 평행인 것 처럼 보정처리하는 방법이다. 4개의 POINT를 설정하여 해당영역의 비율을 조정하여 이미지의 좌표를 변환처리할 수 있다.&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/image_1.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/image_2.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Perspective Transform을 임의의 영상에서 진행하면 다음과 같이 Fied of View를 변경하여 region of interest(ROI)를 lane으로 변경한 것이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_4.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;camera filed of view를 45 degree / 90 degree 로 진행하였을 때 어떤 방향이 더 효율적인가를 처음에 프로젝트 시작할때 고민하여 테스트를 진행&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_5.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;algorithm of project (flow chart)&lt;/p&gt;

&lt;h2 id=&quot;결과&quot;&gt;결과&lt;/h2&gt;

&lt;h3 id=&quot;vanshing-point&quot;&gt;Vanshing Point&lt;/h3&gt;

&lt;p&gt;Box 크기를 조절하여 영상 내부에 소실점의 범위를 규정&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Gaussian Distribution 공식 적용&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;bounding box의 타당성을 검증하기 위해 red dot 이 존재하는 영역의 좌표를 확인 후 Gaussian Distribution을 진행한 결과&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Hough Transform Line Detection을 통해 Vanishing point 검출&lt;/p&gt;

&lt;p&gt;(Hough Transform Line Detection 추가 설명)&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_6.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/td&gt;
      &lt;td&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_7.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;result of Gauissian Distribution for red dot.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_8.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;perspective-transform-1&quot;&gt;Perspective Transform&lt;/h3&gt;

&lt;p&gt;변환 전 4개의 좌표를 직선 구간에서 선정&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;차량이 차선의 중앙이 아닐 경우 판단 가능.
범위를 벗어날 경우 Text 출력으로 현재 주행상태 시각화&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_9.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;두 라인이 검출되면 parallel 하다고 판단한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_10.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;vanishing-point--perspective-transform-결합&quot;&gt;&lt;strong&gt;Vanishing Point &amp;amp; Perspective Transform 결합&lt;/strong&gt;&lt;/h2&gt;

&lt;h3 id=&quot;두-기법의-상호-보완-판단-지표&quot;&gt;두 기법의 상호 보완 판단 지표&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;Confusion matrix 참고하여 발상&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;오류성 주행의 판단 지표&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_11.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;영상에서 각각 [In/Out], [Parallel/Bias] 출력&lt;/li&gt;
  &lt;li&gt;Console에서 위 내용을 결합하여 [직진구간 중앙주행 / 직진구간 치우침, 회전구간 중앙주행 / 회전구간 치우침] 출력&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_12.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_13.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;
&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Bounding Box를 통해 Vanishing point의 직진/회전 구간을 판단.&lt;/li&gt;
  &lt;li&gt;Perspective transform  Lane detection을 적용하여 차량의 치우침을 판단.&lt;/li&gt;
  &lt;li&gt;위 두 조합의 상호보완을 통해 주행 안정성을 향상하는 기법을 제안.&lt;/li&gt;
  &lt;li&gt;오픈된 주행 영상 데이터셋을 이용하여 제안된 방법을 검증.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;적용 가능성&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Untitled_14.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p class=&quot;faded&quot;&gt;참고 Refrence Paper&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/vanishing paper.pd.pdf&quot;&gt;vanishing paper.pd.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/TIP2012.pdf&quot;&gt;TIP2012.pdf&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;a href=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/project/images/computer_vision/Vanishing_Point_Detection_WACV2017.pdf&quot;&gt;Vanishing_Point_Detection_WACV2017.pdf&lt;/a&gt;&lt;/p&gt;</content><author><name>Youngeon</name><email>kye8456@naver.com</email></author><category term="project" /><summary type="html">Vanishing Point &amp;amp; Perspective Transform</summary></entry><entry><title type="html">ROS1 / ROS2</title><link href="http://localhost:4000/devops/ros-content/" rel="alternate" type="text/html" title="ROS1 / ROS2" /><published>2021-12-01T00:00:00+09:00</published><updated>2024-03-25T00:42:06+09:00</updated><id>http://localhost:4000/devops/ros-content</id><content type="html" xml:base="http://localhost:4000/devops/ros-content/">&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/DevOps/images/ros/image.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;rosrobot-operating-system&quot;&gt;ROS(Robot Operating System)&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;로봇 운영체제&lt;/strong&gt;(ROS,Robot Operating System)는 로봇 응용 프로그램을 개발할 때 필요한 하드웨어 추상화, 하위 디바이스 제어, 일반적으로 사용되는 기능의 구현, 프로세스간의 메시지 패싱, 패키지 관리, 개발환경에 필요한 라이브러리와 다양한 개발 및 디버깅 도구를 제공한다. ROS는 로봇 응용 프로그램 개발을 위한 운영체제와 같은 로봇 플랫폼이다. 하드웨어 플랫폼을 하드웨어 추상화로 포함하고 있으며, 로봇 응용 소프트웨어 개발을 지원을 위한 소프트웨어 플랫폼이면서 이기종의 하드웨어에서 사용 가능한 운영체제와 같은 기능을 갖추고 있다.&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:#808080&quot;&gt;출처 : &lt;a href=&quot;https://ko.wikipedia.org/wiki/%EB%A1%9C%EB%B4%87_%EC%9A%B4%EC%98%81%EC%B2%B4%EC%A0%9C&quot;&gt;로봇_운영체제_ROS&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;p&gt;참고,
&lt;span style=&quot;color:#808080&quot;&gt;&lt;a href=&quot;https://www.ros.org/&quot;&gt;ROS: Home&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;ros1-과-ros2의-차이&quot;&gt;ROS1 과 ROS2의 차이&lt;/h2&gt;

&lt;h3 id=&quot;ros1&quot;&gt;ROS1&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;주로 Linux 환경 - &lt;em&gt;Ubuntu 20.04까지 지원 (noetic)&lt;/em&gt;&lt;/li&gt;
  &lt;li&gt;단일 로봇&lt;/li&gt;
  &lt;li&gt;실시간 제어 미지원&lt;/li&gt;
  &lt;li&gt;안정된 네트워크 환경 요구&lt;/li&gt;
  &lt;li&gt;대학, 연구소의 연구 용도&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;ros2&quot;&gt;ROS2&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;다중 노드 통신&lt;/li&gt;
  &lt;li&gt;임베디드 시스템에서 ROS사용&lt;/li&gt;
  &lt;li&gt;실시간 제어&lt;/li&gt;
  &lt;li&gt;불안정한 네트워크 환경 커버 가능&lt;/li&gt;
  &lt;li&gt;멀티 플랫폼 (Windows, Linux, MacOS) 지원&lt;/li&gt;
  &lt;li&gt;최신 기술 지원 (Protocol Buffers, DDS, Websockets 등)&lt;/li&gt;
  &lt;li&gt;상업용 제품 지원&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/eeoon/eeoon.github.io/main/DevOps/images/ros/image1.png&quot; alt=&quot;Untitled&quot; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;span style=&quot;color:#808080&quot;&gt;출처 : &lt;a href=&quot;https://www.lips-hci.com/ros&quot;&gt;https://www.lips-hci.com/ros&lt;/a&gt;&lt;/span&gt;&lt;/p&gt;

&lt;h2 id=&quot;결론&quot;&gt;결론&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;ROS1은 2020년 이후로 공식 릴리즈버전이 없으며 ROS2는 Foxy, Humble, Rolling 등 공식 릴리즈 버전이 제공되고 있다.&lt;/li&gt;
  &lt;li&gt;ROS2 는 ROS1 에서의 큰 단점인 실시간 제어가 가능하다는 장점이 있다.&lt;/li&gt;
  &lt;li&gt;커뮤니티에서도 현재 ROS2에 대한 관심을 갖고 있으며 RosCon에서도 ROS2를 기준으로 언급함.&lt;/li&gt;
  &lt;li&gt;ROS1에서는 Catkin_make를 이용해 소스코드를 build 하지만 ROS2에서는 colcon 을 활용해 build한다.&lt;/li&gt;
  &lt;li&gt;ROS2에서는 다양한 네트워크 환경(DDS/RTPS) 등을 활용하여 유기적인 통신이 가능하다.&lt;/li&gt;
  &lt;li&gt;ROS1에서는 Master-Slave 구조로 연결되어 있다면 ROS2에서는 Master Node가 없기 때문에 PTP(peer to peer) 형태로 다양한 데이터 타입을 효과적으로 교환할 수 있다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>Youngeon</name><email>kye8456@naver.com</email></author><category term="DevOps" /><summary type="html"></summary></entry></feed>